using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection.Metadata.Ecma335;
using System.Text.RegularExpressions;

namespace Microsoft.Dafny;

public interface IHasDocstring {
  /// <summary>
  /// Unfiltered version that only returns the trivia containing the docstring
  /// </summary>
  public string GetTriviaContainingDocstring();
}

public static class NodeExtensions {


  public static IEnumerable<INode> Descendants(this INode node) {
    return node.Children.Concat(node.Children.SelectMany(n => n.Descendants()));
  }

  public static T FindNode<T>(this INode root, Uri uri, DafnyPosition position) {
    return (T)root.FindNodeChain(uri, position, null, node => node is T)?.Data;
  }

  public static INode FindNode(this INode node, Uri uri, DafnyPosition position, Func<INode, bool> predicate) {
    return node.FindNodeChain(uri, position, null, predicate)?.Data;
  }

  public static IEnumerable<INode> FindNodesInUris(this INode node, Uri uri) {
    return node.FindNodeChainsInUri(uri, null).Select(c => c.Data);
  }

  public static IEnumerable<LList<INode>> FindNodeChainsInUri(this INode node, Uri uri, LList<INode> parent) {
    if (node.RangeToken.Uri != null) {
      if (node.RangeToken.Uri == uri) {
        return new[] { new LList<INode>(node, parent) };
      }

      return new LList<INode>[] { };
    }

    var newParent = new LList<INode>(node, parent);
    return node.Children.SelectMany(child => child.FindNodeChainsInUri(uri, newParent));
  }

  private static LList<INode> FindNodeChain(this INode node, Uri uri, DafnyPosition position, LList<INode> parent,
    Func<INode, bool> predicate) {
    if (node.RangeToken.Uri != null) {
      if (node.RangeToken.Uri == uri) {
        return node.FindNodeChain(position, parent, predicate);
      }

      if (node.SingleFileToken) {
        return null;
      }
    }

    var newParent = new LList<INode>(node, parent);
    foreach (var child in node.Children) {
      var result = child.FindNodeChain(uri, position, newParent, predicate);
      if (result != null) {
        return result;
      }
    }

    return null;
  }

  public static LList<INode> FindNodeChain(this INode node, DafnyPosition position, Func<INode, bool> predicate) {
    return FindNodeChain(node, position, new LList<INode>(node, null), predicate);
  }

  private static LList<INode> FindNodeChain(this INode node, DafnyPosition position, LList<INode> parent,
    Func<INode, bool> predicate) {
    if (node.Tok is AutoGeneratedToken || (node.Tok != Token.NoToken && !node.RangeToken.ToDafnyRange().Contains(position))) {
      return null;
    }

    var newParent = new LList<INode>(node, parent);
    foreach (var child in node.Children) {
      var result = child.FindNodeChain(position, newParent, predicate);
      if (result != null) {
        return result;
      }
    }

    if (node.Tok == Token.NoToken || !predicate(node)) {
      return null;
    }

    return new LList<INode>(node, parent);
  }
}